/**
 * @fileoverview Implementa a funcionalidade de busca com correspondência fuzzy para destinos de viagem.
 * Utiliza Fuse.js para pesquisa aproximada e cálculo de relevância ponderada baseada em características dos destinos.
 * @author CESINHAFX
 * @version 1.0.0
 */

import Fuse from 'https://cdn.jsdelivr.net/npm/fuse.js@6.6.2/dist/fuse.esm.js';

/**
 * Configurações para o mecanismo de busca Fuse.js
 * @constant {Object} searchOptions
 * @property {boolean} includeScore - Indica se deve incluir pontuação de relevância nos resultados
 * @property {Array<string>} keys - Campos nos quais realizar a busca
 * @property {number} threshold - Limite de precisão da busca (0 = exato, 1 = qualquer match)
 * @property {number} distance - Distância máxima de Levenshtein para considerar uma correspondência
 */
// Configurações da biblioteca Fuse.js para busca fuzzy
// Opções para o Fuse.js (biblioteca de busca fuzzy)
// Por que: definimos aqui como a busca vai ponderar e onde procurar os termos.
// Dependência: Fuse.js (import acima) e o arquivo `database.json` para os dados.
const searchOptions = {
  includeScore: true,
  keys: ['description', 'name', 'categories'],
  threshold: 0.4
};

// Ensure a global flag is available for coordination with non-module fragments loader
window.headerInitialized = window.headerInitialized ?? false;

// Expose a setup function so the non-module fragments loader can call it after injecting header
window.setupHeaderButtons = function setupHeaderButtons() {
  try {
    if (window.headerInitialized) {
      console.log('[DEBUG] Header already initialized, ignoring setupHeaderButtons');
      return;
    }
    window.headerInitialized = true;

    const searchInput = document.querySelector('#Research') || document.querySelector('.nav-right input[type="text"]');
    if (!searchInput) {
      console.warn('setupHeaderButtons: campo de busca (#Research) não encontrado.');
      return;
    }

    // Ensure results container exists and is consistent
    let resultsContainer = document.getElementById('results') || document.querySelector('.search-results');
    if (!resultsContainer) {
      resultsContainer = document.createElement('div');
      resultsContainer.id = 'results';
      resultsContainer.className = 'search-results';
      const main = document.querySelector('main');
      if (main) main.appendChild(resultsContainer);
      else if (searchInput.parentNode) searchInput.parentNode.appendChild(resultsContainer);
    }

    // Debounced input handler
    let debounceTimer;
    searchInput.addEventListener('input', (e) => {
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(() => {
        const term = e.target.value.trim();
        if (term.length >= 3) {
          if (typeof searchDestinations === 'function') searchDestinations(term);
        } else {
          resultsContainer.innerHTML = '';
        }
      }, 300);
    });

    console.log('[DEBUG] setupHeaderButtons completed');
  } catch (err) {
    console.error('setupHeaderButtons error:', err);
  }
};

/**
 * Carrega o header e inicializa os eventos de busca
 * @returns {Promise<HTMLInputElement>} Promise que resolve quando o header for carregado e inicializado
 */
async function carregarHeaderEInicializar() {
  try {
    // Carrega o conteúdo do header
    const response = await fetch('fragments/header.html');
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
    
    // Converte a resposta em texto
    const html = await response.text();
    
    // Insere o HTML do header
    const headerElement = document.querySelector('header');
    if (!headerElement) {
      throw new Error('Elemento header não encontrado');
    }
    headerElement.innerHTML = html;

    // Inicializa a busca
    const searchInput = document.querySelector('#Research');
    if (!searchInput) {
      throw new Error('Input de busca não encontrado');
    }

    // Configura o evento de input
    searchInput.addEventListener('input', (e) => {
      const searchTerm = e.target.value.trim();
      console.log('Termo de busca:', searchTerm);
      // Aqui você pode chamar a função de busca
    });
    return searchInput;
  } catch (error) {
    console.error('Erro ao carregar header ou inicializar busca:', error);
    return null;
  }
}

// Declare headerInitialized to track initialization state
let headerInitialized = false;

// Inicializa quando o DOM estiver pronto
/**
 * Inicialização principal quando o DOM estiver pronto.
 * Neste bloco procuramos o campo de busca e configuramos todo o fluxo de pesquisa.
 * Por que: deixamos a inicialização aqui para garantir que o HTML principal já exista.
 */

document.addEventListener('DOMContentLoaded', () => {
  if (headerInitialized) return;
  headerInitialized = true;

  console.log('[DEBUG] search.js: DOMContentLoaded disparado, iniciando configuração de busca.');

  // Procuramos o input de busca. Usamos dois seletores como fallback.
  const searchInput = document.querySelector('#Research') ||
                      document.querySelector('.nav-right input[type="text"]');

  // Se não encontrar o campo de busca, não fazemos nada — não há onde exibir resultados.
  if (!searchInput) {
    console.error('search.js: campo de busca (#Research) não encontrado na página.');
    return; // encerra aqui
  }
  

  // Tentamos encontrar um container de resultados existente (p.ex. em uma página dedicada).
  let resultsContainer = document.querySelector('.search-results');

  // Se não existir, criamos um container e o anexamos ao pai do campo de busca.
  // Por que: queremos mostrar resultados diretamente abaixo do input quando possível.
  if (!resultsContainer) {
    resultsContainer = document.createElement('div');
    resultsContainer.id = 'results';
    document.querySelector('main').appendChild(resultsContainer);
    resultsContainer.className = 'search-results';
    if (!searchInput.parentNode) {
      console.error('search.js: Estrutura DOM inválida: searchInput sem parentNode');
      return;
    }
    searchInput.parentNode.appendChild(resultsContainer);
  }

  // --- Funções internas que usam `resultsContainer` e `searchInput` ---

  // Exibe estado de carregamento na área de resultados
  function setLoading(isLoading) {
    // Por que: feedback visual ao usuário enquanto a requisição está em andamento.
    if (isLoading) {
      resultsContainer.innerHTML = `\
        <div class="loading-state">\
          <div class="loading-spinner"></div>\
          <p>Buscando os melhores destinos...</p>\
        </div>`;
    }
  }

  // Renderiza as recomendações obtidas pela busca
  function renderRecommendations(recommendations) {
    console.log('[DEBUG] Entrou em renderRecommendations');
    console.log('[DEBUG] Quantidade de recomendações recebidas:', recommendations.length);
    console.log('[DEBUG] Exemplo de recomendação[0]:', recommendations[0]);
    // Limpa o container antes de renderizar
    resultsContainer.innerHTML = '';

    // Validação simples: se não é array ou está vazio, mostra mensagem amigável
    if (!Array.isArray(recommendations) || recommendations.length === 0) {
      resultsContainer.innerHTML = '<p class="empty">Nenhum destino encontrado</p>';
      return;
    }

    // Mostramos apenas as 2 melhores recomendações para não sobrecarregar a UI
    const topTwo = recommendations.slice(0, 2);

    // Criamos uma seção e preenchemos com cartões simples (imagem + nome + descrição)
    const citiesSection = document.createElement('div');
    
    topTwo.forEach((city, index) => {
    console.log(`[DEBUG] Renderizando item ${index}:`, city.name || city.title);
});
    citiesSection.className = 'cities-recommendation';
    citiesSection.innerHTML = topTwo.map(city => `\
      <div class="recommendation-card">\
        <img src="${city.imageUrl || 'images/placeholder.png'}" alt="${city.name}" onerror="this.src='images/placeholder.png'">\
        <div class="recommendation-card-content">\
          <h3>${city.name}</h3>\
          <p class="score">Match: ${Math.round((city.score || 0) * 100)}%</p>\
          <p>${city.description || 'Sem descrição disponível'}</p>\
        </div>\
      </div>`).join('');

    resultsContainer.appendChild(citiesSection);
  }

  // Função que executa a busca no arquivo database.json usando Fuse.js
  async function searchDestinations(searchTerm) {

    // Por que: abstraímos para poder reutilizar em eventos diferentes (click, input etc.)
    setLoading(true);
    try {
      console.log('[DEBUG] Iniciando busca por termo:', searchTerm);

    
      // Busca o arquivo JSON que contém os destinos (dependência local)
      console.log('[DEBUG] Iniciando fetch do banco de dados...');
      const response = await fetch('./database.json');
      console.log('[DEBUG] Status da resposta HTTP:', response.status);

      if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
      const data = await response.json();
      console.log('[DEBUG] Banco de dados recebido. Chaves:', Object.keys(data));

      // Prepara o Fuse com todos os itens (countries, temples, beaches)
      const fuse = new Fuse(getAllItems(data), searchOptions);
      console.log('[DEBUG] Fuse configurado com itens do banco de dados.');
      // Normaliza o termo e executa a busca
      const results = fuse.search(normalizeText(searchTerm));
      console.log('[DEBUG] Termo original:', searchTerm);
      console.log('[DEBUG] Termo normalizado:', normalizeText(searchTerm));
      console.log('[DEBUG] Resultados brutos do Fuse (qtd):', results.length);
      console.log('[DEBUG] Exemplo de resultado[0]:', results[0]);  
      // Converte o formato retornado por Fuse para um array de objetos com score ponderado
      const recommendations = results.map(r => ({
        ...r.item,  
        score: calculateScore(r.item, r.score)
      })).sort((a, b) => (b.score || 0) - (a.score || 0));
      console.log('[DEBUG] Recomendações finais (ordenadas):', recommendations);
      console.log('[DEBUG] Recomendações processadas (qtd):', recommendations.length);
      console.log('[DEBUG] Exemplo de recomendação[0]:', recommendations[0]);
      renderRecommendations(recommendations);
      console.log('[DEBUG] renderRecommendations concluído');
    } catch (err) {
      console.error('Erro na busca:', err);
      resultsContainer.innerHTML = `\
        <div class="error-state">\
          <p>Erro ao buscar destinos. Tente novamente.</p>\
        </div>`;
    } finally {
      setLoading(false);
      console.log('[DEBUG] searchDestinations finalizado'); 
    }
  }

  // Calcula um score ponderado a partir da pontuação do Fuse e categorias do item
  function calculateScore(item, fuseScore) {
    // Por que: o Fuse retorna 'score' onde 0 = perfeito. Transformamos para uma medida maior = melhor.
    try {
      const baseScore = 1 - (fuseScore || 1);
      const weights = { culture: 0.3, nature: 0.25, adventure: 0.2, relaxation: 0.15, gastronomy: 0.1 };
      let weighted = baseScore;
      if (Array.isArray(item.categories)) {
        item.categories.forEach(cat => {
          if (weights[cat]) weighted += weights[cat];
        });
      }
      return weighted;
    } catch (err) {
      console.error('Erro ao calcular score:', err);
      return 0;
    }
  }

  // Debounce: evita disparar a busca a cada tecla digitada — espera o usuário pausar
  let debounceTimer;
  searchInput.addEventListener('input', (e) => {
    clearTimeout(debounceTimer); // limpa timeout anterior
    debounceTimer = setTimeout(() => {
      const term = e.target.value.trim();
      if (term.length >= 3) {
        // Somente busca quando o termo tem 3 ou mais caracteres (evita ruído)
        searchDestinations(term);
      } else {
        // Limpa resultados se o termo for muito curto
        resultsContainer.innerHTML = '';
      }
    }, 300); // 300ms de espera após o usuário parar de digitar
  });

});

      // Adiciona o container de resultados após o campo de busca
   

    // Estado de loading
    function setLoading(isLoading) {
      const resultsContainer = document.getElementById('results');
      if (isLoading) {
        resultsContainer.innerHTML = `
          <div class="loading-state">
            <div class="loading-spinner"></div>
            <p>Buscando os melhores destinos...</p>
          </div>
        `;
      }
    }

    // Renderiza recomendações
    function renderRecommendations(recommendations) {
      const resultsContainer = document.getElementById('results');
      resultsContainer.innerHTML = '';

      
      if (!Array.isArray(recommendations) || recommendations.length === 0) {

        resultsContainer.innerHTML = '<p class="empty">Nenhum destino encontrado</p>';
        return;
      }

      // Exibe apenas as 2 melhores recomendações
      const topTwo = recommendations.slice(0, 2);
      
      const citiesSection = document.createElement('div');
      citiesSection.className = 'cities-recommendation';
      citiesSection.innerHTML = topTwo.map(city => `
        <div class="recommendation-card">
          <img src="${city.imageUrl || 'images/placeholder.png'}" 
               alt="${city.name}" 
               onerror="this.src='images/placeholder.png'">
          <div class="recommendation-card-content">
            <h3>${city.name}</h3>
            <p class="score">Match: ${Math.round(city.score * 100)}%</p>
            <p>${city.description || 'Sem descrição disponível'}</p>
          </div>
        </div>
      `).join('');

      resultsContainer.appendChild(citiesSection);
    }

    // Busca segura com Promise
    async function searchDestinations(searchTerm) {
      setLoading(true);
      
      try {
        const response = await fetch('./database.json');
          

        
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const data = await response.json();
          console.log('[DEBUG] Banco de dados recebido. Chaves:', Object.keys(data));
          console.log('[DEBUG] Exemplo de countries[0]:', data.countries?.[0]);
          console.log('[DEBUG] Exemplo de temples[0]:', data.temples?.[0]);
          console.log('[DEBUG] Exemplo de beaches[0]:', data.beaches?.[0]);

          console.log('[DEBUG] Termo de busca recebido:', searchTerm);
        // Configura Fuse com todos os destinos
        const fuse = new Fuse(getAllItems(data), searchOptions);
        
        // Busca com termo normalizado
        const results = fuse.search(normalizeText(searchTerm));
        console.log('[DEBUG] Termo original:', searchTerm);
        console.log('[DEBUG] Termo normalizado:', normalizeText(searchTerm));
        
        // Processa resultados com score ponderado
        const recommendations = results
          .map(result => ({
            ...result.item,
            score: calculateScore(result.item, result.score)
          }))
          .sort((a, b) => b.score - a.score);
        console.log('[DEBUG] Resultados brutos do Fuse (qtd):', results.length);
        console.log('[DEBUG] Exemplo de resultado[0]:', results[0]);
        renderRecommendations(recommendations);
          console.log('[DEBUG] Recomendações finais (ordenadas):', recommendations);
        
      } catch (error) {
        console.error('[DEBUG] Erro durante fetch ou parsing:', error);
        const resultsContainer = document.getElementById('results');

        resultsContainer.innerHTML = `
          <div class="error-state">
            <p>Erro ao buscar destinos. Tente novamente.</p>
          </div>
        `;
      } finally {
        setLoading(false);
      }
    }

    // Calcula score ponderado
    function calculateScore(item, fuseScore) {
      try {
        const baseScore = 1 - fuseScore;
        const weights = {
          culture: 0.3,
          nature: 0.25,
          adventure: 0.2,
          relaxation: 0.15,
          gastronomy: 0.1
        };

        let weightedScore = baseScore;
        if (item.categories) {
          item.categories.forEach(category => {
            if (weights[category]) {
              weightedScore += weights[category];
          }
          });
        }
        return weightedScore;
      } catch (error) {
        console.error('Erro ao calcular score:', error);
        return 0;
      }
    }

    

  

// Helpers
function getAllItems(database) {
  const items = [];
  ['countries', 'temples', 'beaches'].forEach(category => {
    if (database[category]) {
      items.push(...database[category]);
    }
  });
  return items;
}

function normalizeText(text) {
  return text.toLowerCase()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '');
}}